// ---------------------------
// ----- Knowledge Graph -----
// ---------------------------

// ----------------------
// ----- Clear Data -----
// ----------------------

// Retrieve all non-standalone nodes (n) with a relation (r) & delete them
MATCH (n)-[r]->() DELETE n, r

// Retrieve all standalone nodes (n) & delete them
MATCH (n) DELETE (n)

// -----------------------------
// ----- Initial Structure -----
// -----------------------------

// Create Node for Each Canton with its FSO-id
LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/geographicsArchitecture/geometryCorrelation/addGeoCorrTables/be-t-00.04-agv-01_KT.csv' AS CantonFSO
CREATE (:canton{
	cantonName:CantonFSO.GDEKT, 
	cantonFSO:CantonFSO.KTNR
});

// Create Year Node for Each Canton
UNWIND range(2016, 2020) as year
MATCH (c:canton)
CREATE (:year{
	year:year,
	cantonName:c.cantonName,
	cantonFSO:c.cantonFSO
});

// Create Relationship Between Year & Canton Nodes
MATCH (c:canton), (y:year)
WHERE EXISTS (c.cantonName) AND EXISTS (y.cantonName) AND c.cantonName=y.cantonName
CREATE (y)-[:STATS_OF_CANTON]->(c)

// ---------------------------------
// ----- demographicsStructure -----
// ---------------------------------

// Create Nodes from '20XX_demographicsStructure_Absolute.csv'
UNWIND [{year:2016, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsStructure/2016_demographicsStructure_Absolute.csv'}, {year:2017, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsStructure/2017_demographicsStructure_Absolute.csv'}, {year:2018, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsStructure/2018_demographicsStructure_Absolute.csv'}, {year:2019, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsStructure/2019_demographicsStructure_Absolute.csv'}, {year:2020, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsStructure/2020_demographicsStructure_Absolute.csv'}] AS demoStrAbs_urls
LOAD CSV WITH HEADERS FROM demoStrAbs_urls.url AS demoStrAbscsv 
CREATE (:demoStrAbs{
	nodeType:'demoStrAbs',
	year:demoStrAbs_urls.year,
	region:demoStrAbscsv.region,
	total:demoStrAbscsv.total,
	age0_19:demoStrAbscsv.age0_19,
	age20_64:demoStrAbscsv.age20_64,
	age65plus:demoStrAbscsv.age65plus,
	sexMale:demoStrAbscsv.sexMale,
	sexFemale:demoStrAbscsv.sexFemale,
	citizenSwiss:demoStrAbscsv.citizenSwiss,
	citizenForeign:demoStrAbscsv.citizenForeign,
	maritalSingle:demoStrAbscsv.maritalSingle,
	maritalMarried:demoStrAbscsv.maritalMarried,
	maritalWidowed:demoStrAbscsv.maritalWidowed,
	maritalDivorced:demoStrAbscsv.maritalDivorced,
	maritalUnmarried:demoStrAbscsv.maritalUnmarried,
	martialRegistredPartnership:demoStrAbscsv.martialRegistredPartnership,
	maritalDisolvedPartnership:demoStrAbscsv.maritalDisolvedPartnership,
	typoUrbanCore:demoStrAbscsv.typoUrbanCore,
	typoUrbanCoreInfluence:demoStrAbscsv.typoUrbanCoreInfluence,
	typoNoUrbanCoreInfluence:demoStrAbscsv.typoNoUrbanCoreInfluence
});

// Create Relationship Between demoStrAbs & year
MATCH (d:demoStrAbs), (y:year)
WHERE EXISTS (d.year) AND EXISTS (y.year) AND d.year=y.year AND EXISTS (d.region) AND EXISTS (y.cantonName) AND d.region=y.cantonName
CREATE (y)-[:ON_TOPIC]->(d)

// ----------------------------------------------
// ------- demographicsLanguages_Absolute -------
// ----------------------------------------------

// Create Nodes from '20XX_demographicsLanguages_Absolute.'
UNWIND [{year:2016, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsLanguages/2016_demographicsLanguages_Absolute.csv'}, {year:2017, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsLanguages/2017_demographicsLanguages_Absolute.csv'}, {year:2018, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsLanguages/2018_demographicsLanguages_Absolute.csv'}, {year:2019, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsLanguages/2019_demographicsLanguages_Absolute.csv'}, {year:2020, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsLanguages/2020_demographicsLanguages_Absolute.csv'}] AS demoLangAbs_urls
LOAD CSV WITH HEADERS FROM demoLangAbs_urls.url AS demoLangAbscsv 
CREATE (:demoLangAbs{
	nodeType:'demoLangAbs',
	year:demoLangAbs_urls.year,
	region:demoLangAbscsv.region,
	total:demoLangAbscsv.total,
	german:demoLangAbscsv.german,
	french:demoLangAbscsv.french,
	italian:demoLangAbscsv.italian,
	romansh:demoLangAbscsv.romansh,
	english:demoLangAbscsv.english,
	portuguese:demoLangAbscsv.portuguese,
	bosnianCroatianMontenegrinSerbian:demoLangAbscsv.bosnianCroatianMontenegrinSerbian,
	albanian:demoLangAbscsv.albanian,
	spanish:demoLangAbscsv.spanish,
	turkish:demoLangAbscsv.turkish,
	otherLanguages:demoLangAbscsv.otherLanguages
});

// Create Relationship Between demoStrAbs & year
MATCH (d:demoLangAbs), (y:year)
WHERE EXISTS (d.year) AND EXISTS (y.year) AND d.year=y.year AND EXISTS (d.region) AND EXISTS (y.cantonName) AND d.region=y.cantonName
CREATE (y)-[:ON_TOPIC]->(d)

// ----------------------------------------------
// ------- demographicsHousehold_Absolute -------
// ----------------------------------------------

// Create nodes from '20XX_demographicsHousehold_Absolute.csv'
UNWIND [{year:2016, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsHousehold/2016_demographicsHousehold_Absolute.csv'}, {year:2017, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsHousehold/2017_demographicsHousehold_Absolute.csv'}, {year:2018, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsHousehold/2018_demographicsHousehold_Absolute.csv'}, {year:2019, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsHousehold/2019_demographicsHousehold_Absolute.csv'}, {year:2020, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsHousehold/2020_demographicsHousehold_Absolute.csv'}] AS demoHouseAbs_urls
LOAD CSV WITH HEADERS FROM demoHouseAbs_urls.url AS demoHouseAbscsv
CREATE (:demoHouseAbs{
	nodeType:'demoHouseAbs',
	year:demoHouseAbs_urls.year,
	region:demoHouseAbscsv.region,
	total:demoHouseAbscsv.total,
	onePersonHousehold:demoHouseAbscsv.onePersonHousehold,
	twoPersonHousehold:demoHouseAbscsv.twoPersonHousehold,
	threePersonHousehold:demoHouseAbscsv.threePersonHousehold,
	fourPersonHousehold:demoHouseAbscsv.fourPersonHousehold,
	fivePersonHousehold:demoHouseAbscsv.fivePersonHousehold,
	sixMorePersonHousehold:demoHouseAbscsv.sixMorePersonHousehold,
	averageSizeHousehold:demoHouseAbscsv.averageSizeHousehold
});

// Create relationship between demoHouseAbs & year
MATCH (d:demoHouseAbs), (y:year)
WHERE EXISTS (d.year) AND EXISTS (y.year) AND d.year=y.year AND EXISTS (d.region) AND EXISTS (y.cantonName) AND d.region=y.cantonName
CREATE (y)-[:ON_TOPIC]->(d)

// ----------------------------------------------
// ------- demographicsEducation_Absolute -------
// ----------------------------------------------

// Create nodes from '20XX_demographicsEducation_Absolute.csv'
UNWIND [{year:2016, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsEducation/2016_demographicsEducation_Absolute.csv'}, {year:2017, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsEducation/2017_demographicsEducation_Absolute.csv'}, {year:2018, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsEducation/2018_demographicsEducation_Absolute.csv'}, {year:2019, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsEducation/2019_demographicsEducation_Absolute.csv'}, {year:2020, url:'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalytics/main/demographicsData/demographicsEducation/2020_demographicsEducation_Absolute.csv'}] AS demoEduAbs_urls
LOAD CSV WITH HEADERS FROM demoEduAbs_urls.url AS demoEduAbscsv
CREATE (:demoEduAbs{
	nodeType:'demoEduAbs20',
	year:demoEduAbs_urls.year,
	region:demoEduAbscsv.region,
	total:demoEduAbscsv.total,
	withoutPostCompulsoryEducation:demoEduAbscsv.withoutPostCompulsoryEducation,
	secondLevel2ProfessionalTraining:demoEduAbscsv.secondLevel2ProfessionalTraining,
	secondLevel2GeneralTraining:demoEduAbscsv.secondLevel2GeneralTraining,
	thirdLevelHigherProfessionalTraining:demoEduAbscsv.thirdLevelHigherProfessionalTraining,
	thirdLevelUniversities:demoEduAbscsv.thirdLevelUniversities
});

// Create relationship between demoEduAbs & year
MATCH (d:demoEduAbs), (y:year)
WHERE EXISTS (d.year) AND EXISTS (y.year) AND d.year=y.year AND EXISTS (d.region) AND EXISTS (y.cantonName) AND d.region=y.cantonName
CREATE (y)-[:ON_TOPIC]->(d)

// ----------------------------------------------------------------------------------------------------
// ------- equidsEffectiveCanton, equidsExportCanton, equidsImportCanton, equidsSummeringCanton -------
// ----------------------------------------------------------------------------------------------------

// Create equids node for each canton/year pair
MATCH (y:year)
CREATE (:equids{
	nodeType:'equids',
	year:y.year,
	cantonName:y.cantonName,
	cantonFSO:y.cantonFSO
});

// Create relationship for each canton/year pair
MATCH (e:equids), (y:year)
WHERE EXISTS (e.cantonName) AND EXISTS (y.cantonName) AND e.cantonName=y.cantonName AND EXISTS (e.year) AND EXISTS (y.year) AND e.year=y.year
CREATE (e)-[:STATS_OF_YEAR]->(y)

// Create nodes from 'fig-equids-canton.csv'
LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalyticsPrivate2/main/equidsCantons/fig-equids-canton.csv' AS equidsEffectiveCantoncsv
CREATE (:equidsEffectiveCanton{
	nodeType:'equidsEffectiveCanton',
	Region:equidsEffectiveCantoncsv.Region,
	Year:toInteger(equidsEffectiveCantoncsv.Year),
	Effective:equidsEffectiveCantoncsv.Effective
});

// Create nodes from 'fig-equids-exportCanton.csv'
LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalyticsPrivate2/main/equidsExport/fig-equids-exportCanton.csv' AS equidsExportCantoncsv
CREATE (:equidsExportCanton{
	nodeType:'equidsExportCanton',
    Region:equidsExportCantoncsv.Region,
	Year:toInteger(equidsExportCantoncsv.Year),
	Export:equidsExportCantoncsv.Export
});

// Create nodes from 'fig-equids-importCanton.csv'
LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/epicalekspwner/OpenDataCustomerAnalyticsPrivate2/main/equidsImport/fig-equids-importCanton.csv' AS equidsImportCantoncsv
CREATE (:equidsImportCanton{
	nodeType:'equidsImportCanton',
    Region:equidsImportCantoncsv.Region,
	Year:toInteger(equidsImportCantoncsv.Year),
	Export:equidsImportCantoncsv.Export
});

// Create relationship between equids & equidsEffectiveCanton
MATCH (e:equids), (eEff:equidsEffectiveCanton)
WHERE EXISTS (e.cantonName) AND EXISTS (eEff.Region) AND e.cantonName=eEff.Region AND EXISTS (e.year) AND EXISTS (eEff.Year) AND e.year=eEff.Year
CREATE (eEff)-[:PART_OF]->(e)

// Create relationship between equids & equidsExportCanton
MATCH (e:equids), (eExp:equidsExportCanton)
WHERE EXISTS (e.cantonName) AND EXISTS (eExp.Region) AND e.cantonName=eExp.Region AND EXISTS (e.year) AND EXISTS (eExp.Year) AND e.year=eExp.Year
CREATE (eExp)-[:PART_OF]->(e)

// Create relationship between equids & equidsImportCanton
MATCH (e:equids), (eImp:equidsImportCanton)
WHERE EXISTS (e.cantonName) AND EXISTS (eImp.Region) AND e.cantonName=eImp.Region AND EXISTS (e.year) AND EXISTS (eImp.Year) AND e.year=eImp.Year
CREATE (eImp)-[:PART_OF]->(e)


















MATCH



//
//
//



// Display graph
MATCH (n) RETURN n